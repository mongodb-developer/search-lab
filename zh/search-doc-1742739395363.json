{"searchDocs":[{"title":"👐 为您的应用程序添加全文搜索","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/add-to-app/add-to-app","content":"","keywords":"","version":"当前版本"},{"title":"在 Node.js 中使用聚合管道​","type":1,"pageTitle":"👐 为您的应用程序添加全文搜索","url":"/search-lab/zh/docs/add-to-app/add-to-app#在-nodejs-中使用聚合管道","content":" 要在 Node.js 中使用聚合管道，您需要在集合对象上使用 aggregate 方法。该方法接受一个阶段数组作为参数，并返回一个游标。然后，您可以使用游标迭代结果，或者使用 toArray 方法将结果获取为一个数组。  const documents = await collection.aggregate(aggregationPipelines).toArray();   现在，您已经了解了为应用程序添加全文搜索功能所需的一切。  ","version":"当前版本","tagName":"h2"},{"title":"将搜索添加到图书馆应用程序​","type":1,"pageTitle":"👐 为您的应用程序添加全文搜索","url":"/search-lab/zh/docs/add-to-app/add-to-app#将搜索添加到图书馆应用程序","content":" 打开 server/src/controllers/books.ts 文件中的代码。在其中，查找 searchBooks 函数。  现在，它使用正则表达式查询数据库。  public async searchBooks(query: string): Promise&lt;Book[]&gt; { const books = await collections?.books?.find({ title: {$regex: new RegExp(query, &quot;i&quot;)} }).toArray(); return books; }   虽然这段代码在某种程度上是有效的，但它并不是最优的。随着数据集的增长，这个查询的性能会下降，因为它将不得不扫描整个集合。您无法使用正则表达式查询索引。此外，该查询仅匹配标题，并且仅匹配确切的字符序列。  将此代码更改为使用搜索索引。您需要在聚合管道中使用 $search 阶段。让您的搜索覆盖标题、作者姓名和类型数组。  这段代码将放在 server/src/controllers/books.ts 文件中的 searchBooks 函数中。  点击这里查看答案 public async searchBooks(query: string): Promise&lt;Book[]&gt; { const aggregationPipeline = [ { $search: { index: 'fulltextsearch', text: { query, path: ['title', 'authors.name', 'genres'] } } } ]; const books = await collections?.books?.aggregate(aggregationPipeline).toArray() as Book[]; return books; }   在应用程序中尝试一下，看看您得到的结果。您应该会看到结果比之前更加相关。 ","version":"当前版本","tagName":"h2"},{"title":"👐 构建搜索查询","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/aggregations/search-stage","content":"","keywords":"","version":"当前版本"},{"title":"在 Atlas UI 中进行聚合​","type":1,"pageTitle":"👐 构建搜索查询","url":"/search-lab/zh/docs/aggregations/search-stage#在-atlas-ui-中进行聚合","content":" 导航到数据库部署的 Collections 选项卡，选择 books 集合，然后从集合详情下的导航栏中导航到 Aggregation 选项卡。    提示 此时 Atlas UI 可能会显得有点拥挤。你也可以使用 Compass 中的聚合管道构建器来获得更好的体验。  点击 Add Stage 按钮，并在 select 输入框中输入 $search。    为 $search 阶段添加以下代码。  { index: &quot;fulltextsearch&quot;, text: { query: &quot;cooking&quot;, path: [&quot;title&quot;] } }   该阶段使用 &quot;fulltextsearch&quot; 索引。如果索引是 &quot;default&quot;，你不需要显式定义索引，但为了清晰起见，你可以保留它。  text 操作符将在 title 字段中搜索 &quot;cooking&quot;。你应该在右侧看到返回的文档集合。  点击 Add Stage 按钮，向下滚动并选择 $project 作为第 2 阶段。    为 $project 阶段添加以下实现代码来过滤返回的字段。  { title: 1, authors: 1, genres: 1, pages: 1 }   此时，你应该看到与上一节相似的结果，因为这几乎是相同的查询。 ","version":"当前版本","tagName":"h2"},{"title":"🦸 创建索引","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/facet/create-index","content":"🦸 创建索引 为了使用分面搜索，你需要创建适当的索引。 使用 JSON 编辑器创建一个新的搜索索引。使用以下 JSON 作为你的索引定义。 { &quot;mappings&quot;: { &quot;dynamic&quot;: false, &quot;fields&quot;: { &quot;genres&quot;: { &quot;type&quot;: &quot;stringFacet&quot; }, &quot;year&quot;: { &quot;type&quot;: &quot;number&quot; } } } } 像之前的练习那样创建一个新索引。 一旦索引准备好了，你可以继续下一步。","keywords":"","version":"当前版本"},{"title":"🦸 分面介绍","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/facet/intro","content":"🦸 分面介绍 分面是一种基于共同值将文档分组的方法。例如，如果你有一个电影列表，你可能想按类型对它们进行分组。然后你可以使用分面来过滤结果，只显示某一类型的电影。 一个常见的用例是使用分面来创建过滤器。你可以在大多数电子商务网站上看到这一点。例如，你会看到页面左侧的一列类别，每个类别旁边都有一个数字。这个数字表示该类别中的产品数量。 { &quot;facet&quot;: { &quot;operator&quot;: { &quot;range&quot;: { &quot;path&quot;: &quot;year&quot;, &quot;gte&quot;: 2000, &quot;lte&quot;: 2015 } }, &quot;facets&quot;: { &quot;genresFacet&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;path&quot;: &quot;genres&quot; } } } } ","keywords":"","version":"当前版本"},{"title":"📘 全文搜索","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/full-text-search","content":"","keywords":"","version":"当前版本"},{"title":"什么是 Atlas Search？​","type":1,"pageTitle":"📘 全文搜索","url":"/search-lab/zh/docs/full-text-search#什么是-atlas-search","content":" Atlas Search 与其他 Atlas 服务集成，为你提供完全托管的搜索服务。它构建于领先的开源搜索引擎库 Lucene 之上，同时也建立在 MongoDB 的聚合框架之上，这意味着你可以使用相同的查询语言来查询和搜索你的数据。  ","version":"当前版本","tagName":"h2"},{"title":"Atlas Search 的优势​","type":1,"pageTitle":"📘 全文搜索","url":"/search-lab/zh/docs/full-text-search#atlas-search-的优势","content":" 你已经看到了使用 MongoDB 查询语言查询数据的局限性。Atlas Search 为你提供了几个好处：  全文搜索 - Atlas Search 为你提供全文搜索功能，包括词干提取、停用词和同义词。评分 - Atlas Search 为你提供评分系统，允许你根据相关性对搜索结果进行排序。语言支持 - Atlas Search 开箱即用地支持多种语言。自动补全 - Atlas Search 为你提供搜索内容自动补全功能。高亮显示 - Atlas Search 为你提供高亮显示功能。 ","version":"当前版本","tagName":"h2"},{"title":"📘 为什么选择 Atlas Search","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/full-text-search/why-atlas-search","content":"","keywords":"","version":"当前版本"},{"title":"如何使用 Atlas Search​","type":1,"pageTitle":"📘 为什么选择 Atlas Search","url":"/search-lab/zh/docs/full-text-search/why-atlas-search#如何使用-atlas-search","content":" 要使用 Atlas Search，你需要创建一个搜索索引。搜索索引是一种包含你想要搜索的数据和搜索规则的数据结构。你可以使用 Atlas UI 或 Atlas API 创建搜索索引。  一旦创建了索引，你就可以使用 MongoDB 查询 API 来查询数据。这将通过聚合管道中的新 $search 操作符来完成。 ","version":"当前版本","tagName":"h2"},{"title":"🦸 使用分面查询","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/facet/query","content":"🦸 使用分面查询 现在你的索引已经到位，你可以使用它进行查询了。 你需要使用 $searchMeta 聚合阶段来查询你的数据。你可以在 Atlas Search 文档 中找到更多关于这个阶段及其使用方法的信息。 现在你已经在 genres 和 year 字段上创建了索引，尝试创建一个查询，返回2000年代出版的每个类型的书籍数量。 点击查看答案 { $searchMeta: { &quot;index&quot;: &quot;facetsIndexName&quot;, &quot;facet&quot;: { &quot;operator&quot;: { &quot;range&quot;: { &quot;path&quot;: &quot;year&quot;, &quot;gte&quot;: 2000, &quot;lte&quot;: 2010 } }, &quot;facets&quot;: { &quot;genresFacet&quot;: { &quot;type&quot;: &quot;string&quot;, &quot;path&quot;: &quot;genres&quot; } } } } } ","keywords":"","version":"当前版本"},{"title":"📘 Atlas Search 如何工作","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/full-text-search/how-search-works","content":"","keywords":"","version":"当前版本"},{"title":"简单的字符串搜索​","type":1,"pageTitle":"📘 Atlas Search 如何工作","url":"/search-lab/zh/docs/full-text-search/how-search-works#简单的字符串搜索","content":" 当你在数据库中使用 LIKE 操作符或正则表达式进行简单查询时，数据库必须扫描集合中的每个文档以找到匹配的文档。这是一个缓慢的过程，随着集合中文档数量的增加，它会变得更慢。    ","version":"当前版本","tagName":"h2"},{"title":"全文搜索​","type":1,"pageTitle":"📘 Atlas Search 如何工作","url":"/search-lab/zh/docs/full-text-search/how-search-works#全文搜索","content":" 全文搜索旨在搜索大量文本。例如，搜索引擎将使用全文搜索在其索引的所有网页中查找关键字。这种技术的关键是索引。  索引可以通过不同的方式完成，如批量索引或增量索引。然后，索引充当任何匹配文档的广泛词汇表。然后可以使用各种技术来提取数据。开源搜索库 Apache Lucene 使用倒排索引来查找匹配的项目。在我们的全文搜索中，每个词汇链接到匹配的文档项。    对于大量数据，这种技术比字符串搜索快得多。  ","version":"当前版本","tagName":"h2"},{"title":"索引创建​","type":1,"pageTitle":"📘 Atlas Search 如何工作","url":"/search-lab/zh/docs/full-text-search/how-search-works#索引创建","content":" 为了准备你的数据进行索引，你的数据将经过一个叫做分词的过程。分词是将文本流分解成单词、短语、符号或其他有意义元素（称为标记）的过程。这是通过一系列分词器完成的。分词器是搜索引擎的构建模块，它们负责从文本中生成标记。然后，这些标记存储在索引中。  在我们的示例中，它将首先去除任何变音符号（字母上方或下方的标记，如法语中的 é、à 和 ç）。然后，根据所使用的语言，算法将删除填充词，只保留词汇的词干。这样，“to eat”、“eating”和“ate”都被归类为相同的“eat”关键字。然后，它将大小写更改为仅使用大写或小写。确切的索引过程由所使用的分词器决定。    最后，索引将看起来像你数据中所有有意义词汇的词汇表。每个词汇都将链接到包含它的文档。   ","version":"当前版本","tagName":"h2"},{"title":"📘 为什么需要搜索","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/full-text-search/why-search","content":"📘 为什么需要搜索 搜索是一种强大的工具，可以为你的用户创造更好的体验。它将帮助他们更快、更高效地找到他们正在寻找的内容。它还将帮助他们发现他们原本不知道的内容。 越来越多的用户在访问网站时期望有类似 Google 的搜索体验。他们希望能够只输入几个单词就能获取他们正在寻找的内容。他们不希望为了找到所需内容而必须浏览复杂的页面层次结构。 如果他们找不到所需内容，他们将离开你的网站并转到其他地方。这对于经常在路上的移动用户尤其如此，他们没有时间浏览复杂的页面层次结构。 为你的网站添加搜索功能 有很多方法可以为你的网站添加搜索功能。其中一种最流行的方法是使用开源搜索引擎，如 Elasticsearch 或 Solr。这些搜索引擎非常强大，可以用于索引和搜索数百万文档。 在幕后，这两个搜索引擎都使用 Lucene 来建立索引和搜索文档。Lucene 是一个 Java 库，提供了一个简单的 API 用于索引和搜索文档。 要使用这些工具，你需要在你的数据和搜索引擎之间实现一个同步机制。 这可能是一项复杂的任务，需要大量工作。","keywords":"","version":"当前版本"},{"title":"📘 Introduction to Hybrid Search","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/hybrid-search/intro","content":"","keywords":"","version":"当前版本"},{"title":"What is Hybrid Search?​","type":1,"pageTitle":"📘 Introduction to Hybrid Search","url":"/search-lab/zh/docs/hybrid-search/intro#what-is-hybrid-search","content":" Hybrid search is an advanced information retrieval technique that combines multiple search methodologies to provide more accurate and relevant results. In the context of our library management system, we'll be focusing on a hybrid approach that merges two powerful search paradigms:    Vector Search: Also known as semantic search, this method uses mathematical representations (vectors) of text to find similarities based on meaning rather than exact word matches.Full-Text Search: This traditional method looks for exact or close matches of words and phrases within text fields.  ","version":"当前版本","tagName":"h2"},{"title":"Why Use Hybrid Search?​","type":1,"pageTitle":"📘 Introduction to Hybrid Search","url":"/search-lab/zh/docs/hybrid-search/intro#why-use-hybrid-search","content":" Hybrid search offers several advantages over using either vector or full-text search alone:  Improved Accuracy: By combining semantic understanding with keyword matching, hybrid search can capture both conceptual similarity and specific term relevance.Better Handling of Complex Queries: It can effectively process queries that might be ambiguous or require understanding of context.Enhanced User Experience: Users can find relevant results even when they don't know the exact terms to search for.Balancing Precision and Recall: Hybrid search helps in finding a good balance between returning highly specific results and a broader range of relevant items.  ","version":"当前版本","tagName":"h2"},{"title":"Hybrid Search in Our Library Management System​","type":1,"pageTitle":"📘 Introduction to Hybrid Search","url":"/search-lab/zh/docs/hybrid-search/intro#hybrid-search-in-our-library-management-system","content":" In our library application, hybrid search will allow us to:  Find books based on their cover images.Match books by title, author, synopsis or other metadata fields.Combine these approaches to rank results in a way that considers both content similarity and metadata relevance.  For example, a search for &quot;space exploration&quot; could return:  Books with covers that constains stars, planets, satellites etc.Books directly about space exploration (matched by title or synopsis)Science fiction novels set in space (matched semantically)Biographies of astronauts (matched by related concepts) ","version":"当前版本","tagName":"h2"},{"title":"📘 介绍","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/intro","content":"","keywords":"","version":"当前版本"},{"title":"📘👐🦸 导航栏图标​","type":1,"pageTitle":"📘 介绍","url":"/search-lab/zh/docs/intro#-导航栏图标","content":" 这些实验是由我们出色的讲师之一呈现的，但你也可以自己完成。  在导航栏中，你会注意到一些图标。它们的含义如下：  图标\t含义📘\t讲义材料 - 如果您正在跟随导师主导的课程，他们可能已经覆盖了这些材料。 👐\t动手内容 - 准备好进行一些实际操作。您应该按照这些步骤进行。 🦸\t高级内容 - 这些内容在实验期间未覆盖，但如果您有兴趣了解更多，可以查看。 ","version":"当前版本","tagName":"h2"},{"title":"📘 equals 操作符","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/search-operators/equals","content":"📘 equals 操作符 equals 操作符用于在字段中搜索特定值。它类似于 match 操作符，但操作将由 Lucene 执行，并且可以与其他操作符结合使用以优化结果。 equals 操作符的语法如下。您可以在文档中找到更多解释。 { $search: { &quot;index&quot;: &lt;index name&gt;, // 可选，默认为 &quot;default&quot; &quot;equals&quot;: { &quot;path&quot;: &quot;&lt;field-to-search&gt;&quot;, &quot;value&quot;: &lt;boolean-value&gt;|&lt;objectId&gt;|&lt;number&gt;|&lt;date&gt;, &quot;score&quot;: &lt;score-options&gt; } } } 如果您只想查询在特定年份出版的书籍，这将非常有用。","keywords":"","version":"当前版本"},{"title":"🦸‍♂️ Implementing Hybrid Search","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/hybrid-search/implementing-hybrid-search","content":"","keywords":"","version":"当前版本"},{"title":"Prerequites​","type":1,"pageTitle":"🦸‍♂️ Implementing Hybrid Search","url":"/search-lab/zh/docs/hybrid-search/implementing-hybrid-search#prerequites","content":" This segment depends on the setup you have done in previous exercises:  Ensure you have created an Atlas Search index on the books collection with dynamic mappings.Ensure you have imported the embeddings.Ensure you have created the vector search index on the embeddings field.  ","version":"当前版本","tagName":"h2"},{"title":"Function for Full-Text Search​","type":1,"pageTitle":"🦸‍♂️ Implementing Hybrid Search","url":"/search-lab/zh/docs/hybrid-search/implementing-hybrid-search#function-for-full-text-search","content":" Write a new function called fullTextSearch in books.ts:  It accepts query as an argument of string type, and limit as an argument of number typeUsing query, it should perform a full-text search on title, synopsis, and author names, and you may boost scores at your own discretionIt should limit the number of books returned using the limit argument parsedUsing $project to only return the following book properties: _id, title, authors, synopsis, and cover  Answer public async fullTextSearch(query: string,limit: number): Promise&lt;Book[]&gt;{ const pipeline = [ { $search: { index: &quot;fulltextsearch&quot;, compound: { should: [ { text: { query, path: &quot;title&quot;, score: { boost: { value: 3 } } } }, { text: { query, path: &quot;synopsis&quot;, score: { boost: { value: 2 } } } }, { text: { query, path: &quot;authors.name&quot;, score: { boost: { value: 2 } } } } ] } } },{ $limit: limit },{ $project:{ //project only relevant fields title: 1, authors: 1, synopsis:1, cover:1 } } ] const books = await collections?.books?.aggregate(pipeline).toArray() as Book[]; return books; }   ","version":"当前版本","tagName":"h2"},{"title":"Function for Vector Search​","type":1,"pageTitle":"🦸‍♂️ Implementing Hybrid Search","url":"/search-lab/zh/docs/hybrid-search/implementing-hybrid-search#function-for-vector-search","content":" Write a new function called vectorSearch in books.ts:  It accepts query as an argument of string type, and limit as an argument of number typeIt should vectorize the query and use resulting vector to perform a vector search on books collection.It should limit the number of books returned using the limit argument parsedUsing $project to only return the following book properties: _id, title, authors, synopsis, and cover  Answer public async vectorSearch(query: string, limit: number): Promise&lt;Book[]&gt;{ const vector = await getEmbeddings(query); const pipeline = [ { $vectorSearch: { queryVector: vector, path: 'embeddings', numCandidates: 100, index: 'vectorsearch', limit: limit, } },{ $project:{ //project only relevant fields title: 1, authors: 1, synopsis:1, cover:1 } } ] const books = await collections?.books?.aggregate(pipeline).toArray() as Book[]; return books; }   ","version":"当前版本","tagName":"h2"},{"title":"Function to compute Weighted Reciprocal Rank Fusion​","type":1,"pageTitle":"🦸‍♂️ Implementing Hybrid Search","url":"/search-lab/zh/docs/hybrid-search/implementing-hybrid-search#function-to-compute-weighted-reciprocal-rank-fusion","content":" Atlas full-text search and vector search, by default, returns documents sorted by their relevancy score from highest to lowest i.e. they are ranked by default.  A reciprocal rank score is given by 1 / (RANK * RANK_CONSTANT). A RANK_CONSTANT (typically about 60), prevents the case of 1/0 where RANK is 0, and smoothens the scores so that it is not too heavily skewed towards higher ranked documents.  You may give different weightage to full-text search versus vector search by multiplying the scores with a different weight.  Write a new private function called computeWeightedRRF in books.ts:  It accepts books as an argument of Book[] type, and weight as an argument of number typeIt should compute the Reciprocal Rank score based on its position in the array (the first book in the array should be ranked 0).Mulitply the score further by the given weight and store the resultant score as score back into the book object.  Answer private computeWeightedRRF(books: Book[], weight: number): void{ const RANK_CONSTANT = 60; books.forEach((book,i)=&gt;{ book['score'] = weight*1/(i+RANK_CONSTANT) return book; }) }   ","version":"当前版本","tagName":"h2"},{"title":"Function to perform Hybrid Search​","type":1,"pageTitle":"🦸‍♂️ Implementing Hybrid Search","url":"/search-lab/zh/docs/hybrid-search/implementing-hybrid-search#function-to-perform-hybrid-search","content":" The final thing we need to do is to combine the scores by summing the scores from both types of searches. If the same book is found in two searches, the score should be summed up giving it a higher score.  Replace the searchBooks function in books.ts:  It accepts query as an argument of string typeIt should execute both full-text search and vector search based on the queryIt should parse both results into the computeWeightedRRF. Lets give full-text search a weight of 0.5 and vector search a weight of 0.5.Sum the two scores from both sets of results, re-rank the books based on the new scores and return the top 5 books  Answer public async searchBooks(query: string): Promise&lt;Book[]&gt; { const VECTOR_WEIGHT = 0.5; const FULL_TEXT_WEIGHT = 0.5; const SEARCH_LIMIT = 5 //run full text search and vector search separately const [fts_results,vs_results] = await Promise.all([ this.fullTextSearch(query, SEARCH_LIMIT), this.vectorSearch(query, SEARCH_LIMIT) ]) //compute weighted Reciprocal Rank Fusion on both results this.computeWeightedRRF(fts_results, FULL_TEXT_WEIGHT) this.computeWeightedRRF(vs_results, VECTOR_WEIGHT) //aggregate both arrays to a single map using _id as a key const documentMap = [...fts_results,...vs_results].reduce((map,book:any)=&gt;{ if(map.hasOwnProperty(book._id)){ map[book._id].score += book.score; }else{ map[book._id] = book; } return map; },{}) //transform map back to an array const books = Object.keys(documentMap).map(k=&gt;documentMap[k]); //return books with the highest scores const topBooks = books.sort((a,b)=&gt;b.score-a.score).slice(0,SEARCH_LIMIT); return topBooks; }  ","version":"当前版本","tagName":"h2"},{"title":"🦸 高级练习","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/search-operators/advanced-exercises","content":"","keywords":"","version":"当前版本"},{"title":"提升短书优先级​","type":1,"pageTitle":"🦸 高级练习","url":"/search-lab/zh/docs/search-operators/advanced-exercises#提升短书优先级","content":" 你注意到读者倾向于喜欢较短的书籍。在不使用boost进行分数提升的情况下，尝试在搜索结果中提升较短的书籍。  提示 即使不使用分数调整器，should操作符仍然会提升符合条件的文档的分数。  答案 public async searchBooks(query: string): Promise&lt;Book[]&gt; { const aggregationPipeline = [ { $search: { &quot;index&quot;: &quot;fulltextsearch&quot;, &quot;compound&quot;: { &quot;must&quot;: [ { &quot;text&quot;: { query, &quot;path&quot;: [&quot;title&quot;, &quot;authors.name&quot;, &quot;genres&quot;], fuzzy: { maxEdits: 2 } } } ], &quot;should&quot;: [ { &quot;equals&quot;: { &quot;value&quot;: true, &quot;path&quot;: &quot;bookOfTheMonth&quot;, &quot;score&quot;: { &quot;boost&quot;: { value: 10 } } } }, { &quot;range&quot;: { path: &quot;pages&quot;, lt: 80 } } ] } } } ]; const books = await collections?.books?.aggregate(aggregationPipeline).toArray() as Book[]; return books; }   选择你最喜欢的方式来构建聚合管道，并尝试解决以下练习。  ","version":"当前版本","tagName":"h2"},{"title":"最多可借阅的本月书籍​","type":1,"pageTitle":"🦸 高级练习","url":"/search-lab/zh/docs/search-operators/advanced-exercises#最多可借阅的本月书籍","content":" 构建一个搜索聚合语句，提升本月书籍的优先级，并首先返回具备最多可借阅副本的书籍。  ","version":"当前版本","tagName":"h2"},{"title":"最多产的“pooh”作者​","type":1,"pageTitle":"🦸 高级练习","url":"/search-lab/zh/docs/search-operators/advanced-exercises#最多产的pooh作者","content":" 找出哪位作者写了最多的“pooh”这个词，在标题或简介中出现的书籍都算。  ","version":"当前版本","tagName":"h2"},{"title":"假设有拼写错误，但仍然找到匹配项​","type":1,"pageTitle":"🦸 高级练习","url":"/search-lab/zh/docs/search-operators/advanced-exercises#假设有拼写错误但仍然找到匹配项","content":" 找到与用户查询匹配的书籍，但也返回与拼写错误匹配的书籍。这些书籍应在与查询匹配的书籍之后返回。 ","version":"当前版本","tagName":"h2"},{"title":"📘 搜索操作符简介","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/search-operators/intro","content":"📘 搜索操作符简介 在上一个练习中，您使用了一个类似这样的 $search 阶段。 { $search: { index: 'fulltextsearch', text: { query, path: ['title', 'authors.name', 'categories'] } } } 我们已经讨论过 $search 阶段及其 index 属性，但目前为止，我们只在最简单的形式中使用了 text 操作符。 然而，当您希望优化搜索结果时，您需要使用更高级的操作符，甚至结合一些操作符以获得所需的结果。 在这个练习中，我们将探索一些最常见的操作符以及如何使用它们。","keywords":"","version":"当前版本"},{"title":"👐 练习","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/search-operators/exercises","content":"","keywords":"","version":"当前版本"},{"title":"添加模糊搜索​","type":1,"pageTitle":"👐 练习","url":"/search-lab/zh/docs/search-operators/exercises#添加模糊搜索","content":" 尝试在你的应用中添加模糊搜索功能，以便即使用户输入有拼写错误也能找到正确的书籍。  提示 还记得 text 操作符的 fuzzy 参数吗？就是在这里使用它。  答案 public async searchBooks(query: string): Promise&lt;Book[]&gt; { const aggregationPipeline = [ { $search: { index: 'fulltextsearch', text: { query, path: ['title', 'authors.name', 'genres'], fuzzy: { maxEdits: 2 } } } } ]; const books = await collections?.books?.aggregate(aggregationPipeline).toArray() as Book[]; return books; }   ","version":"当前版本","tagName":"h2"},{"title":"推广月度推荐书籍​","type":1,"pageTitle":"👐 练习","url":"/search-lab/zh/docs/search-operators/exercises#推广月度推荐书籍","content":" 市场团队决定要推广月度推荐书籍。他们希望在搜索结果中首先显示这些书籍。你会怎么做呢？  提示 你需要在这里使用 compound 操作符和多个操作符。你可以使用一些书籍上的 bookOfTheMonth 布尔字段。  答案 public async searchBooks(query: string): Promise&lt;Book[]&gt; { const aggregationPipeline = [ { $search: { &quot;index&quot;: &quot;fulltextsearch&quot;, &quot;compound&quot;: { &quot;must&quot;: [ { &quot;text&quot;: { query, &quot;path&quot;: [&quot;title&quot;, &quot;authors.name&quot;, &quot;genres&quot;], fuzzy: { maxEdits: 2 } } } ], &quot;should&quot;: [ { &quot;equals&quot;: { &quot;value&quot;: true, &quot;path&quot;: &quot;bookOfTheMonth&quot;, &quot;score&quot;: { &quot;boost&quot;: { value: 10 } } } } ] } } } ]; const books = await collections?.books?.aggregate(aggregationPipeline).toArray() as Book[]; return books; }  ","version":"当前版本","tagName":"h2"},{"title":"🦸‍♂️ Testing the Hybrid Search","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/hybrid-search/testing-hybrid-search","content":"🦸‍♂️ Testing the Hybrid Search 信息 Extra activity, do it if you have extra time or are following at home, won't be covered during the hands-on Lab. Here's the complete code snippet to implement a hybrid search against the books collection. See complete code //... private computeWeightedRRF(books: Book[], weight: number): void{ const RANK_CONSTANT = 60; books.forEach((book,i)=&gt;{ book['score'] = weight*1/(i+RANK_CONSTANT) return book; }) } public async fullTextSearch(query: string,limit: number): Promise&lt;Book[]&gt;{ const pipeline = [ { $search: { index: &quot;fulltextsearch&quot;, compound: { should: [ { text: { query, path: &quot;title&quot;, score: { boost: { value: 3 } } } }, { text: { query, path: &quot;synopsis&quot;, score: { boost: { value: 2 } } } }, { text: { query, path: &quot;authors.name&quot;, score: { boost: { value: 2 } } } } ] } } },{ $limit: limit },{ $project:{ //project only relevant fields title: 1, authors: 1, synopsis:1, cover:1 } } ] const books = await collections?.books?.aggregate(pipeline).toArray() as Book[]; return books; } public async vectorSearch(query: string, limit: number): Promise&lt;Book[]&gt;{ const vector = await getEmbeddings(query); const pipeline = [ { $vectorSearch: { queryVector: vector, path: 'embeddings', numCandidates: 100, index: 'vectorsearch', limit: limit, } },{ $project:{ //project only relevant fields title: 1, authors: 1, synopsis:1, cover:1 } } ] const books = await collections?.books?.aggregate(pipeline).toArray() as Book[]; return books; } public async searchBooks(query: string): Promise&lt;Book[]&gt; { const VECTOR_WEIGHT = 0.4; const FULL_TEXT_WEIGHT = 0.6; const SEARCH_LIMIT = 5 //run full text search and vector search separately const [fts_results,vs_results] = await Promise.all([ this.fullTextSearch(query, SEARCH_LIMIT), this.vectorSearch(query, SEARCH_LIMIT) ]) //compute weighted Reciprocal Rank Fusion on both results this.computeWeightedRRF(fts_results, FULL_TEXT_WEIGHT) this.computeWeightedRRF(vs_results, VECTOR_WEIGHT) //aggregate both arrays to a single map using _id as a key const documentMap = [...fts_results,...vs_results].reduce((map,book:any)=&gt;{ if(map.hasOwnProperty(book._id)){ map[book._id].score += book.score; }else{ map[book._id] = book; } return map; },{}) //transform map back to an array const books = Object.keys(documentMap).map(k=&gt;documentMap[k]); //return books with the highest scores const topBooks = books.sort((a,b)=&gt;b.score-a.score).slice(0,SEARCH_LIMIT); return topBooks; } //... You can observe the effect of hybrid search on the search results by tuning the VECTOR_WEIGHT and FULL_TEXT_WEIGHT. Lets use the search term basketball and compare the results. Note that your results may look different as we may periodically make changes to the dataaset. Lets start with setting VECTOR_WEIGHT=0 and FULL_TEXT_WEIGHT=1 i.e. the results will be based on 100% full-text search. Here are the top 5 titles: The New York Knicks Basketball Team (Great Sports Teams)In the Land of Giants: My Life in BasketballVenus to the Hoop: A Gold Medal Year in Women's BasketballNight HoopsCat (Fear Street Series #45) Now, lets set VECTOR_WEIGHT=1 and FULL_TEXT_WEIGHT=0 i.e. the results will be based on 100% vector search. Here are the top 5 titles: NBA: The Official Fan's GuideIn the Land of Giants: My Life in BasketballNight HoopsVenus to the Hoop: A Gold Medal Year in Women's BasketballThe Big Three Finally, lets set VECTOR_WEIGHT=0.5 and FULL_TEXT_WEIGHT=0.5 i.e. we are placing equal empahasis on full-text search and vector search. Here are the top 5 titles: In the Land of Giants: My Life in BasketballVenus to the Hoop: A Gold Medal Year in Women's BasketballNight HoopsThe New York Knicks Basketball Team (Great Sports Teams)NBA: The Official Fan's Guide Key observations: From the full-text search result, Cat (Fear Street Series #45) can be seen as a false positive because it may have little to do with basketball but it is only there because the synopsis contains the word basketball.From the vector search result, The Big Three made it to the top 5 because it showed a few basketball players on its cover image, but this title was missed in the full-text search because neither the title nor the synopsis contains the word basketball.From the hybrid search result, titles that made it to both types of search were ranked higher","keywords":"","version":"当前版本"},{"title":"📘 range 操作符","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/search-operators/range","content":"📘 range 操作符 range 操作符类似于 equals，但适用于值的范围。 range 操作符的语法如下。您可以在文档中找到更多解释。 { &quot;$search&quot;: { &quot;index&quot;: &lt;index name&gt;, // 可选，默认为 &quot;default&quot; &quot;range&quot;: { &quot;path&quot;: &quot;&lt;field-to-search&gt;&quot;, &quot;gt | gte&quot;: &lt;value-to-search&gt;, &quot;lt | lte&quot;: &lt;value-to-search&gt;, &quot;score&quot;: &lt;score-options&gt; } } } 如果您只想查询页数在一定范围内的书籍，这将非常有用。例如，如果您只想要 100 到 300 页之间的书籍，您可以使用 range 操作符来优化结果。","keywords":"","version":"当前版本"},{"title":"📘 phrase 操作符","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/search-operators/phrase","content":"","keywords":"","version":"当前版本"},{"title":"slop 属性​","type":1,"pageTitle":"📘 phrase 操作符","url":"/search-lab/zh/docs/search-operators/phrase#slop-属性","content":" slop 属性用于指定短语中的单词可以相隔多远。默认值是 0，这意味着单词必须按查询中指定的确切顺序排列。如果将值设置为 1，则单词之间可以相隔一个单词，依此类推。 ","version":"当前版本","tagName":"h2"},{"title":"📘 混合和匹配","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/search-operators/mix-and-match","content":"","keywords":"","version":"当前版本"},{"title":"使用评分的复合查询​","type":1,"pageTitle":"📘 混合和匹配","url":"/search-lab/zh/docs/search-operators/mix-and-match#使用评分的复合查询","content":" 您还可以使用 compound 操作符和 score 选项来控制子查询评分的组合方式。假设图书馆有一个月度主题，他们希望推广在简介中包含特定词的书籍。本月的主题是 &quot;bears&quot;。试着写一个搜索查询，将用户查询的书籍返回，但包含 &quot;bear&quot; 一词的书籍评分更高，并排在前面。试着让一本关于 Winnie the Pooh 的书在用户搜索 &quot;honey&quot; 时排在第一位。  点击查看答案 { &quot;index&quot;: &quot;fulltextsearch&quot;, &quot;compound&quot;: { &quot;must&quot;: [ { &quot;text&quot;: { &quot;query&quot;: &quot;honey&quot;, &quot;path&quot;: [&quot;title&quot;, &quot;author.name&quot;, &quot;synopsis&quot;] } } ], &quot;should&quot;: [ { &quot;text&quot;: { &quot;query&quot;: &quot;bear&quot;, &quot;path&quot;: &quot;synopsis&quot;, &quot;score&quot;: { &quot;boost&quot;: { value: 10 } } } } ] } }  ","version":"当前版本","tagName":"h2"},{"title":"📘 评分修饰符","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/search-operators/score-modifier","content":"","keywords":"","version":"当前版本"},{"title":"提升 (Boost)​","type":1,"pageTitle":"📘 评分修饰符","url":"/search-lab/zh/docs/search-operators/score-modifier#提升-boost","content":" 使用 boost，您可以将评分乘以某个值。这对于提升某些结果的分数非常有用。较高的提升等级会得到更高的修饰符。  在我们的数据集中，我们可以决定提升属于 fiction 类型的结果。  { $search: { index: 'fulltextsearch', text: { query: 'fiction', path: 'genres' }, score: { boost: { value: 2 } } } }   ","version":"当前版本","tagName":"h2"},{"title":"常量 (Constant)​","type":1,"pageTitle":"📘 评分修饰符","url":"/search-lab/zh/docs/search-operators/score-modifier#常量-constant","content":" 我们也可以将评分设置为一个常量值。这对于贬低不够相关的结果非常有用。在我们的用例中，我们可以为当前不可用的书籍设置一个常量值 0。  { $search: { index: 'fulltextsearch', equals: { path: 'available', value: 0 }, score: { constant: { value: 0 } } } }  ","version":"当前版本","tagName":"h2"},{"title":"📘 评分","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/search-operators/scoring","content":"📘 评分 您可能已经注意到，大多数操作符都有一个 score 属性，但我们还没有真正讨论过它。 在深入了解评分之前，重要的是要理解文档评分是什么。每个由 Atlas Search 查询返回的文档都会根据相关性分配一个评分，并且结果集中包含的文档会按从高到低的评分顺序返回。 一些可以影响评分的因素包括： 搜索词在文档中的位置，搜索词在文档中出现的频率，查询使用的操作符类型，查询使用的分析器类型。 要查看评分，您需要使用 $meta 投影一个新的元数据字段。要在简单的短语搜索 Alice in Wonderland 中查看文档评分，请尝试以下聚合管道。 您可以在 Atlas UI 或 Compass 的聚合构建器中运行此代码。 [ { $search: { index: &quot;fulltextsearch&quot;, phrase: { query: &quot;Alice in Wonderland&quot;, path: &quot;title&quot;, }, }, }, { $project: { title: 1, authors: 1, pages: 1, year: 1, score: { $meta: &quot;searchScore&quot;, }, }, }, ] 您的第一个结果应该是 { &quot;_id&quot;: &quot;0831702877&quot;, &quot;title&quot;: &quot;Alice in Wonderland&quot;, &quot;authors&quot;: [ { &quot;_id&quot;: &quot;64cc2db4830ba29148da7bbc&quot;, &quot;name&quot;: &quot;Walt Disney Productions&quot; }, { &quot;_id&quot;: &quot;64cc2db4830ba29148da8db5&quot;, &quot;name&quot;: &quot;Mouse Works&quot; } ], &quot;pages&quot;: 95, &quot;year&quot;: 1997, &quot;score&quot;: 10.441896438598633 } 它得分比下一个高得多，因为它是一个完全匹配。","keywords":"","version":"当前版本"},{"title":"📘 text 操作符","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/search-operators/text","content":"","keywords":"","version":"当前版本"},{"title":"fuzzy 属性​","type":1,"pageTitle":"📘 text 操作符","url":"/search-lab/zh/docs/search-operators/text#fuzzy-属性","content":" 模糊搜索是一种允许您搜索与目标词相似的术语的技术。当用户在搜索查询中可能会拼写错误或拼写错误时，它非常有用。  fuzzy 属性有许多选项，您可以在文档中找到更多信息。现在，我们将重点关注 maxEdits 选项。MaxEdits 将指定可以进行的字符编辑的数量以找到匹配项。  例如，如果您搜索 Alice，您应该找到书 Alice in Wonderland。但是，如果您有一个或多个拼写错误，如 Alyse、Alise 或 Allice，您将找不到这本书。这时 maxEdits 选项就派上用场了。设置为 1 的 maxEdits，您即使有一个拼写错误也能找到这本书。  ","version":"当前版本","tagName":"h2"},{"title":"synonyms 属性​","type":1,"pageTitle":"📘 text 操作符","url":"/search-lab/zh/docs/search-operators/text#synonyms-属性","content":" synonyms 属性允许您指定将在搜索中使用的同义词映射。例如，如果您搜索 car，您可能也想找到包含 automobile 这个词的文档。您可以在索引配置中指定同义词映射，然后在搜索查询中使用 synonyms 属性来使用该映射。 ","version":"当前版本","tagName":"h2"},{"title":"👐 开始使用","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/search/intro","content":"👐 开始使用 在本节中，你将看到开始使用 MongoDB Atlas Search 是多么简单。 警告 此时，你应该已经在 Codespace 中运行了示例应用程序，并加载了包含图书馆数据的免费集群。如果你还没有这样做，请先完成 入门实验。","keywords":"","version":"当前版本"},{"title":"🎯 总结","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/summary","content":"🎯 总结 恭喜你！通过本教程，你已经成功地： 了解了什么是全文搜索和 Atlas Search将全文搜索添加到你的应用中将语义搜索添加到你的应用中 访问 MongoDB 开发者中心 获取更多有用的信息和教程。","keywords":"","version":"当前版本"},{"title":"👐 测试搜索索引","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/search/test-search","content":"","keywords":"","version":"当前版本"},{"title":"搜索测试器​","type":1,"pageTitle":"👐 测试搜索索引","url":"/search-lab/zh/docs/search/test-search#搜索测试器","content":" 使用上面的 QUERY 按钮，你将打开 搜索测试器。在字段中输入单词：  cooking   然后查看你得到的结果。    你可以看到你搜索到了一系列书籍，包括：  Pennsylvania Dutch Cooking: A Mennonite Community CookbookSemi-Homemade Cooking: Quick, Marvelous Meals and Nothing is Made from…Cookin' Cajun Cooking School Cookbook - Creole and Cajun Cuisine from …  所有这些结果都匹配了单词 cooking。请注意，大小写并不重要，单词在标题中的位置也不重要。搜索索引足够智能，能够在所有这些标题中找到单词 cooking。  现在，你已经为你的用户提供了更好的搜索体验。  ","version":"当前版本","tagName":"h2"},{"title":"仅搜索标题​","type":1,"pageTitle":"👐 测试搜索索引","url":"/search-lab/zh/docs/search/test-search#仅搜索标题","content":" 这很棒。然而，这个搜索查询正在搜索整个文档。在某些情况下，这可能对你有用，但在大多数情况下，你可能只想限制搜索到相关的字段。在这种情况下，让我们将其更改为仅搜索标题。  在 搜索测试器 中，点击绿色 Search 按钮旁边的 编辑 $search 查询 按钮。  这将打开查询编辑器。    请注意，path 属性目前显示为 *。这意味着它将搜索整个文档。尝试将搜索更改为仅搜索 title 字段。  提示 你可以在 搜索文档 中找到更多关于如何构建查询路径的信息。  点击这里查看答案 [ { $search: { index: &quot;fulltextsearch&quot;, text: { query: &quot;cooking&quot;, path: [&quot;title&quot;] } } } ]   你会看到相同的结果，但顺序不同。这与相关性有关，但我们将在后面的章节中讨论。 ","version":"当前版本","tagName":"h2"},{"title":"👐 创建一个 Atlas Search 索引","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/search/search-index","content":"","keywords":"","version":"当前版本"},{"title":"创建第一个 Atlas Search 索引的分步指南​","type":1,"pageTitle":"👐 创建一个 Atlas Search 索引","url":"/search-lab/zh/docs/search/search-index#创建第一个-atlas-search-索引的分步指南","content":" 打开 MongoDB Atlas 中的 Clusters 页面，然后在右下角选择 Create Index。    点击 Create Search Index 按钮。    构建搜索索引的第一步是选择配置方法。你可以从两种选项中选择——使用 Visual Editor 或使用 JSON Editor 自行编写配置。让我们保持默认的 Visual Editor。要继续，请点击 Next。    接下来，你需要为索引选择一个名称和数据源。将名称更改为 fulltextsearch，并选择数据库 library 和集合 books。    最后一步允许你审查索引配置并在需要时进行改进。你还可以通过点击 View JSON 查看从你的配置生成的 JSON。  { &quot;mappings&quot;: { &quot;dynamic&quot;: true } }   信息 该索引使用动态字段映射。我们没有在文档和搜索索引之间配置任何明确（静态）的映射。这就是为什么 Atlas 创建了动态映射，将文档中的数据匹配到一些常见字段类型，如 double、string、array 和 int。 动态映射在你刚开始使用 Atlas Search 或你的模式经常变化时非常有用。然而，与静态映射相比，它们占用更多空间。  你不需要改进此索引。继续点击 Create Search Index。    你将被重定向到一个页面，显示你的 Atlas 项目中使用的所有搜索索引。创建索引大约需要一分钟。  信息 当你的搜索索引状态变为 Active 时，你将能够看到更多关于索引的信息。例如，索引的文档数量、字段映射和索引大小。还要注意，你使用的是免费 M0 数据库附带的 3 个免费搜索索引中的 1 个额度。    当你看到新索引在列表中显示为 Active 时，你可以继续下一步。 ","version":"当前版本","tagName":"h2"},{"title":"👐 将语义搜索添加到您的应用程序","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/vector-search/add-to-app","content":"","keywords":"","version":"当前版本"},{"title":"配置环境变量​","type":1,"pageTitle":"👐 将语义搜索添加到您的应用程序","url":"/search-lab/zh/docs/vector-search/add-to-app#配置环境变量","content":" 在您的 server/.env 文件中，您会发现一些可以用来配置应用程序的变量。在文件末尾添加几个变量，以配置嵌入源和 API 密钥。  EMBEDDINGS_SOURCE=serverlessEndpoint EMBEDDING_KEY=&lt;API Key&gt;   提示 您的导师将为您提供一个 API 密钥，您可以在参加的活动中使用。将其设置在 EMBEDDING_KEY 变量中。  ","version":"当前版本","tagName":"h2"},{"title":"配置向量搜索查询​","type":1,"pageTitle":"👐 将语义搜索添加到您的应用程序","url":"/search-lab/zh/docs/vector-search/add-to-app#配置向量搜索查询","content":" 再次打开 server/src/controllers/books.ts 文件，并编辑 searchBooks 方法，以查询您的语义搜索数据。  提示 使用 getEmbeddings 函数将查询转换为向量。  答案 public async searchBooks(query: string): Promise&lt;Book[]&gt; { const vector = await getEmbeddings(query); const aggregationPipeline = [ { $vectorSearch: { queryVector: vector, path: 'embeddings', numCandidates: 100, index: 'vectorsearch', limit: 100, } } ]; const books = await collections?.books?.aggregate(aggregationPipeline).toArray() as Book[]; return books; }   ","version":"当前版本","tagName":"h2"},{"title":"测试语义搜索​","type":1,"pageTitle":"👐 将语义搜索添加到您的应用程序","url":"/search-lab/zh/docs/vector-search/add-to-app#测试语义搜索","content":" 要在应用程序中测试语义搜索，请尝试搜索一些书籍，但使用不同的词语，这些词语具有相似的含义或与书籍封面相关。  您可以使用以下短语进行查询：  狗狗做事情毛绒绒的动物欧洲历史 ","version":"当前版本","tagName":"h2"},{"title":"👐 创建向量搜索索引","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/vector-search/create-index","content":"","keywords":"","version":"当前版本"},{"title":"创建向量搜索索引的分步指南​","type":1,"pageTitle":"👐 创建向量搜索索引","url":"/search-lab/zh/docs/vector-search/create-index#创建向量搜索索引的分步指南","content":" 打开 MongoDB Atlas 中的 Clusters 页面，并在右下角选择 Create Index。    点击 Create Search Index 按钮。    这次，你将使用 JSON Editor 来创建索引。    选择你的数据库和 books 集合，将索引名称更改为 vectorsearch，并在 JSON 编辑器中添加以下代码：  Serverless EndpointOpenAIGoogle Cloud Vertex AI { &quot;fields&quot;:[ { &quot;type&quot;: &quot;vector&quot;, &quot;path&quot;: &quot;embeddings&quot;, &quot;numDimensions&quot;: 1408, &quot;similarity&quot;: &quot;cosine&quot; } ] }   最后一步允许你查看索引配置并在需要时进行优化。继续点击 Create Search Index。 ","version":"当前版本","tagName":"h2"},{"title":"使用 Amazon SageMaker","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/vector-search/create-vectors/ws-sagemaker","content":"","keywords":"","version":"当前版本"},{"title":"开始使用 Amazon SageMaker​","type":1,"pageTitle":"使用 Amazon SageMaker","url":"/search-lab/zh/docs/vector-search/create-vectors/ws-sagemaker#开始使用-amazon-sagemaker","content":" 只需按照这个教程的第 2 部分中的步骤进行操作，并将其适应我们一直在使用的图书馆信息。  使用 Amazon SageMaker、AWS Lambda 和 AWS API Gateway 创建你的模型端点 ","version":"当前版本","tagName":"h2"},{"title":"📘 实现向量搜索","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/vector-search/implementing-vector-search","content":"","keywords":"","version":"当前版本"},{"title":"向量化你的数据集​","type":1,"pageTitle":"📘 实现向量搜索","url":"/search-lab/zh/docs/vector-search/implementing-vector-search#向量化你的数据集","content":" 首先，你需要创建数据的数学表示。这称为向量化。在“创建向量”部分，你将学习如何使用一些主要的编码器创建向量。  然而，在本次研讨会的背景下，我们已经为你完成了这项工作。你可以使用之前使用的导入工具来导入带有嵌入的数据。  ","version":"当前版本","tagName":"h2"},{"title":"向量化你的查询​","type":1,"pageTitle":"📘 实现向量搜索","url":"/search-lab/zh/docs/vector-search/implementing-vector-search#向量化你的查询","content":" 第二个部分是向量化你的查询。这与向量化数据集的过程相同，但不是向量化一个大数据集，而是向量化一个单一的查询。  重要的是要对你的数据集和查询使用相同的编码器。这是因为编码器学习了一种特定的方式来表示数据。如果你使用不同的编码器，向量会不同，搜索将无法正常工作。  在本次研讨会中，你将使用提供的函数之一来向量化你的查询。同样，自己实现这部分代码的完整内容在“创建向量”部分中。 ","version":"当前版本","tagName":"h2"},{"title":"使用 OpenAI","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/vector-search/create-vectors/openai","content":"","keywords":"","version":"当前版本"},{"title":"创建 OpenAI 账户并获取 API 密钥​","type":1,"pageTitle":"使用 OpenAI","url":"/search-lab/zh/docs/vector-search/create-vectors/openai#创建-openai-账户并获取-api-密钥","content":" 要创建账户，请访问 https://openai.com/ 并点击右上角的“登录”按钮。这将重定向您到登录页面，您可以选择注册他们的服务。    按照屏幕上的说明操作，并验证您的电子邮件地址。  一旦您有了账户，就可以转到 API 密钥页面 获取 API 密钥。  在那里，点击 创建新密钥 按钮。    您将被提示给您的密钥命名。您可以将其称为“MongoDB 向量搜索演示”。然后点击 创建密钥 按钮。  然后会显示您的 API 密钥。复制它并保存在安全的地方。    警告 请确保您将此密钥复制到某个地方以便稍后使用，之后您将无法再次看到它。  现在您有了 API 密钥，可以用它为您的文档创建嵌入。  ","version":"当前版本","tagName":"h2"},{"title":"为文档创建嵌入​","type":1,"pageTitle":"使用 OpenAI","url":"/search-lab/zh/docs/vector-search/create-vectors/openai#为文档创建嵌入","content":" 要通过发送 curl 命令到 OpenAI API 为您的文档创建嵌入，您可以使用以下命令。  OPENAI_API_KEY=&lt;YOUR_API_KEY&gt; curl https://api.openai.com/v1/embeddings \\ -H &quot;Authorization: Bearer $OPENAI_API_KEY&quot; \\ -H &quot;Content-Type: application/json&quot; \\ -d '{ &quot;input&quot;: &quot;The food was delicious and the waiter...&quot;, &quot;model&quot;: &quot;text-embedding-ada-002&quot; }'   您可以在 OpenAI 文档 中找到有关该 API 的更多信息。  ","version":"当前版本","tagName":"h2"},{"title":"为书籍创建嵌入​","type":1,"pageTitle":"使用 OpenAI","url":"/search-lab/zh/docs/vector-search/create-vectors/openai#为书籍创建嵌入","content":" 要为您的集合中的书籍创建嵌入，您应该为每本书运行此 curl 命令，或使用 Node.js 库。这个过程有点耗时，所以我们已经为您创建了它们。  您可以在书籍的 embeddings 字段中找到 1586 维度的向量。  因为我们已经有了书籍的向量，所以我们可以用它们进行向量搜索。  ","version":"当前版本","tagName":"h2"},{"title":"使用向量进行查询​","type":1,"pageTitle":"使用 OpenAI","url":"/search-lab/zh/docs/vector-search/create-vectors/openai#使用向量进行查询","content":" 要查询数据，向量搜索需要计算查询向量与集合中文档向量之间的距离。  为此，您需要向量化您的查询。您可以使用相同的函数来向量化您的查询。  在图书馆应用程序中，我们创建了一个函数来为您向量化查询。您可以在 server/src/embeddings/openai.ts 文件中找到它。  import OpenAI from 'openai'; const { EMBEDDING_KEY } = process.env; let openai; const getTermEmbeddings = async (text) =&gt; { if (!openai) { openai = new OpenAI({apiKey: EMBEDDING_KEY}); } const embeddings = await openai.embeddings.create({ model: 'text-embedding-ada-002', input: text, }); return embeddings?.data[0]?.embedding; }; export default getTermEmbeddings;   ","version":"当前版本","tagName":"h2"},{"title":"配置应用程序​","type":1,"pageTitle":"使用 OpenAI","url":"/search-lab/zh/docs/vector-search/create-vectors/openai#配置应用程序","content":" 在 server/.env 文件中，您会找到一些变量，可以用来配置应用程序。  第一个是 EMBEDDINGS_SOURCE。它告诉应用程序从哪里获取嵌入。您可以将其设置为 openai。  现在您有了 OpenAI API 密钥，可以将 ","version":"当前版本","tagName":"h2"},{"title":"📘 语义搜索","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/vector-search/semantic-search","content":"","keywords":"","version":"当前版本"},{"title":"什么是语义搜索？​","type":1,"pageTitle":"📘 语义搜索","url":"/search-lab/zh/docs/vector-search/semantic-search#什么是语义搜索","content":" 语义搜索是一种使用词语含义来查找相关结果的搜索技术。它是推动我们现在看到的大语言模型的动力。  使用语义搜索，即使搜索词不出现在结果中，我们也能找到相关结果。例如，如果我们搜索“如何做蛋糕”，我们可以找到包含“如何烤蛋糕”或“如何做馅饼”词语的结果。  这是通过向量完成的。向量是词语的数学表示。它们用于找到词语之间的相似性。例如，“蛋糕”这个词与“馅饼”这个词相似，因为它们都是甜点。  ","version":"当前版本","tagName":"h2"},{"title":"如何创建语义搜索引擎​","type":1,"pageTitle":"📘 语义搜索","url":"/search-lab/zh/docs/vector-search/semantic-search#如何创建语义搜索引擎","content":" 在我们的图书馆应用程序中，让我们改变搜索栏的工作方式。试着改变搜索栏的行为，根据书籍的含义而不仅仅是词语本身来查找书籍。  这将帮助我们在搜索“瘟疫末日”时找到《The Stand（末日逼近）》这本书。（用中文搜索同样能搜到英文相关书籍）  即使这些词不出现在书名或描述中，我们也希望能够找到它们。  你可以使用类似的方法为你的客户提供与他们正在查看的项目相似的项目。例如，如果客户正在查看一双登山靴，你可以向他们展示他们可能需要的其他装备。  ","version":"当前版本","tagName":"h2"},{"title":"MongoDB 在哪里发挥作用？​","type":1,"pageTitle":"📘 语义搜索","url":"/search-lab/zh/docs/vector-search/semantic-search#mongodb-在哪里发挥作用","content":" 凭借其文档模型，MongoDB 非常适合存储向量。你可以将向量作为数字数组存储在文档中。  当需要搜索相关结果时，我们可以像进行全文搜索一样，利用 Lucene 的强大功能。 ","version":"当前版本","tagName":"h2"},{"title":"👐 导入向量化数据","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/vector-search/import-data","content":"","keywords":"","version":"当前版本"},{"title":"导入嵌入​","type":1,"pageTitle":"👐 导入向量化数据","url":"/search-lab/zh/docs/vector-search/import-data#导入嵌入","content":" 要导入具有预创建嵌入的数据集，您可以使用之前使用的导入工具。  在顶部的文本框中输入您的连接字符串，并从屏幕底部的下拉菜单中选择您的提供者。    提示 如果不确定，或者不想创建自己的嵌入，您可以使用无服务器端点提供者。  选择提供者后，点击添加嵌入按钮。  注意 此过程将删除您现有的books集合，并以新集合替换。任何现有的索引或对集合的更改将丢失。  导入完成后，您会看到确认消息。 ","version":"当前版本","tagName":"h2"},{"title":"使用 Google Cloud Vertex AI","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/vector-search/create-vectors/google-vertex","content":"","keywords":"","version":"当前版本"},{"title":"创建 Google Cloud 账号​","type":1,"pageTitle":"使用 Google Cloud Vertex AI","url":"/search-lab/zh/docs/vector-search/create-vectors/google-vertex#创建-google-cloud-账号","content":" 第一步是创建一个 Google Cloud 账号。使用以下链接开始并获得一些免费积分。  注册 Google Cloud 账号  ","version":"当前版本","tagName":"h2"},{"title":"创建新项目​","type":1,"pageTitle":"使用 Google Cloud Vertex AI","url":"/search-lab/zh/docs/vector-search/create-vectors/google-vertex#创建新项目","content":" 在欢迎屏幕上，创建一个新项目。你可以随意命名。  确保选择一个活跃的结算账户。    填写完字段后，点击 创建 按钮。  ","version":"当前版本","tagName":"h2"},{"title":"打开 Cloud Shell​","type":1,"pageTitle":"使用 Google Cloud Vertex AI","url":"/search-lab/zh/docs/vector-search/create-vectors/google-vertex#打开-cloud-shell","content":" 项目创建完成后，在屏幕右上角寻找 激活 Cloud Shell 按钮。    这将在浏览器中打开一个类似终端的窗口。这是一个完全功能的终端，连接到云中的虚拟机。你可以使用这个终端在虚拟机上运行命令。  ","version":"当前版本","tagName":"h2"},{"title":"启用 AI Platform API​","type":1,"pageTitle":"使用 Google Cloud Vertex AI","url":"/search-lab/zh/docs/vector-search/create-vectors/google-vertex#启用-ai-platform-api","content":" 你需要为项目启用 AI Platform API。你可以通过在 Cloud Shell 中运行以下命令来实现。  gcloud services enable aiplatform.googleapis.com   ","version":"当前版本","tagName":"h2"},{"title":"创建认证文件​","type":1,"pageTitle":"使用 Google Cloud Vertex AI","url":"/search-lab/zh/docs/vector-search/create-vectors/google-vertex#创建认证文件","content":" 要使用 AI Platform API 进行身份验证，你需要创建一个包含应用凭据的文件。你可以通过在 Cloud Shell 中运行以下命令来实现。  gcloud auth application-default login   按照终端中的指示使用 Google Cloud 账号进行身份验证。身份验证完成后，你会看到类似以下的信息。  Credentials saved to file: [/tmp/tmp.n0HdRFDDv8/application_default_credentials.json]   将凭据文件保存到你的主目录。  mv /tmp/tmp.n0HdRFDDv8/application_default_credentials.json ~/credentials.json   ","version":"当前版本","tagName":"h2"},{"title":"创建一些文本的嵌入​","type":1,"pageTitle":"使用 Google Cloud Vertex AI","url":"/search-lab/zh/docs/vector-search/create-vectors/google-vertex#创建一些文本的嵌入","content":" 为了创建一些文本的嵌入，你将首先创建一个 request.json 文件。这个文件将包含你要转换为嵌入的文本。在 Cloud Shell 中运行以下命令来创建这个文件。  echo '{ &quot;instances&quot;: [ { &quot;text&quot;: &quot;picture of a cat&quot; } ] }' &gt;&gt; request.json   现在运行以下 curl 命令以获取文本的嵌入。  curl -X POST \\ -H &quot;Authorization: Bearer $(gcloud auth print-access-token)&quot; \\ -H &quot;Content-Type: application/json; charset=utf-8&quot; \\ -d @request.json \\ &quot;https://us-central1-aiplatform.googleapis.com/v1/projects/$PROJECT_ID/locations/us-central1/publishers/google/models/multimodalembedding@001:predict&quot;   确保将 $PROJECT_ID 变量更改为你的项目 ID。  你将收到类似以下的响应  { &quot;predictions&quot;: [ { &quot;textEmbedding&quot;: [ -0.00566103263, 0.0202014241, -0.00677233562, 0.0180264488, 0.0265100803, ... 0.00116232142, 0.0134601779, -0.00257002981 ] } ], &quot;deployedModelId&quot;: &quot;5595742328217141248&quot; }   你会注意到 textEmbeddings 字段包含一个 1408 个数字的数组。这些是你提供的文本的嵌入。  ","version":"当前版本","tagName":"h2"},{"title":"为书籍创建嵌入​","type":1,"pageTitle":"使用 Google Cloud Vertex AI","url":"/search-lab/zh/docs/vector-search/create-vectors/google-vertex#为书籍创建嵌入","content":" 为了为你的书籍集合创建嵌入，你应该为每本书运行这个 curl 命令。这个过程有点耗时，所以我们已经为你创建好了。  你可以在导入的新书籍集合的 embeddings 字段中找到 1408 维的向量。  因为我们已经有了这些书籍的向量，我们可以使用它们进行向量搜索。  ","version":"当前版本","tagName":"h2"},{"title":"使用向量进行查询​","type":1,"pageTitle":"使用 Google Cloud Vertex AI","url":"/search-lab/zh/docs/vector-search/create-vectors/google-vertex#使用向量进行查询","content":" 为了查询数据，向量搜索需要计算查询向量与集合中文档向量之间的距离。  为此，你需要将查询向量化。你可以使用相同的函数来向量化你的查询。  在图书馆应用程序中，我们已经创建了一个函数来为你向量化查询。你可以在 server/embeddings/googleVertex.mjs 文件中找到它。  import aiplatform from '@google-cloud/aiplatform'; const project = process.env.PROJECT_ID; const location = process.env.PROJECT_LOCATION; const {PredictionServiceClient} = aiplatform.v1; const {helpers} = aiplatform; const predictionServiceClient = new PredictionServiceClient({ apiEndpoint: 'us-central1-aiplatform.googleapis.com' }); const getTermEmbeddings = async (text) =&gt; { const publisher = &quot;google&quot;; const model = 'multimodalembedding@001'; // 配置父资源 const endpoint = `projects/${project}/locations/${location}/publishers/${publisher}/models/${model}`; const instance = { text }; const instanceValue = helpers.toValue(instance); const instances = [instanceValue]; const request = { endpoint, instances }; // 预测请求 const [response] = await predictionServiceClient.predict(request); const embeddings = response.predictions[0].structValue.fields.textEmbedding.listValue.values.map(e =&gt; e.numberValue); return embeddings; }; export default getTermEmbeddings;   ","version":"当前版本","tagName":"h2"},{"title":"配置应用程序​","type":1,"pageTitle":"使用 Google Cloud Vertex AI","url":"/search-lab/zh/docs/vector-search/create-vectors/google-vertex#配置应用程序","content":" 在你的 server/.env 文件中，你会找到几个变量，用于配置应用程序。  第一个是 EMBEDDINGS_SOURCE。它告诉应用程序从哪里获取嵌入。你可以将其设置为 googleVertex。  然后将 EMBEDDING_KEY 设置为你的 credentials.json 文件。  最后，将 PROJECT_ID 和 PROJECT_LOCATION 设置为你的项目的值。  EMBEDDINGS_SOURCE=googleVertex EMBEDDING_KEY=&quot;./credentials.json&quot; PROJECT_ID=projectphoenix-verteximage PROJECT_LOCATION=us-central1   你的应用程序现在有一个 getTermEmbeddings 函数，它将返回给定文本的嵌入。你可以在 server/src/embeddings/googleVertex.js 文件中查看此文件的详细信息。 ","version":"当前版本","tagName":"h2"},{"title":"🦸‍♂️ 预过滤数据","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/vector-search/filtering","content":"","keywords":"","version":"当前版本"},{"title":"使用数值字段进行预过滤​","type":1,"pageTitle":"🦸‍♂️ 预过滤数据","url":"/search-lab/zh/docs/vector-search/filtering#使用数值字段进行预过滤","content":" 如果我们想预先过滤所有 2001 年的书籍，可以尝试以下（但目前不会生效）：  [ {$vectorSearch: { queryVector: vector, path: &quot;embeddings&quot;, numCandidates: 100, index: &quot;vectorsearch&quot;, limit: 100, filter: {year: {$eq: 2001}} } } ]   ","version":"当前版本","tagName":"h2"},{"title":"使用字符串字段进行预过滤​","type":1,"pageTitle":"🦸‍♂️ 预过滤数据","url":"/search-lab/zh/docs/vector-search/filtering#使用字符串字段进行预过滤","content":" 我们可以尝试以下，同样不会生效：  [ {$vectorSearch: { queryVector: vector, path: &quot;embeddings&quot;, numCandidates: 100, index: &quot;vectorsearch&quot;, limit: 100, filter: {language: {$eq: &quot;es&quot;}} } } ]   问题出在 vectorsearch 索引，而不是这段代码。要对字符串字段进行预过滤，需要在我们的搜索索引定义中添加对这些字段的映射。为此，进入 MongoDB Atlas，进入你的集合并再次打开搜索索引选项卡，正如你在 创建索引 时所做的那样。  在这种情况下，我们已经有了索引，我们将要在 JSON 编辑器中编辑它。只需在索引中添加 year 字段和 language 字段的映射。索引应如下所示：  { &quot;fields&quot;: [ { &quot;type&quot;: &quot;vector&quot;, &quot;path&quot;: &quot;embeddings&quot;, &quot;numDimensions&quot;: 1536, &quot;similarity&quot;: &quot;cosine&quot; }, { &quot;type&quot;: &quot;filter&quot;, &quot;path&quot;: &quot;year&quot; }, { &quot;type&quot;: &quot;filter&quot;, &quot;path&quot;: &quot;language&quot; } ] }   唯一的区别是我们添加了以下部分，声明 year 和 language 应作为 filter 进行索引。   { &quot;type&quot;: &quot;filter&quot;, &quot;path&quot;: &quot;year&quot; }, { &quot;type&quot;: &quot;filter&quot;, &quot;path&quot;: &quot;language&quot; }   在代码中添加新的聚合管道（server/src/controllers/books.ts 中熟悉的 searchBooks 方法），进行搜索时，你会得到用西班牙语编写的语义结果。 ","version":"当前版本","tagName":"h2"},{"title":"📘 什么是向量？","type":0,"sectionRef":"#","url":"/search-lab/zh/docs/vector-search/what-are-vector","content":"","keywords":"","version":"当前版本"},{"title":"为什么我们需要向量？​","type":1,"pageTitle":"📘 什么是向量？","url":"/search-lab/zh/docs/vector-search/what-are-vector#为什么我们需要向量","content":" 计算机不能理解文本。它们只能理解数字。所以，我们需要一种方法将文本转换为数字。这就是向量的作用。  使用向量，我们可以在多维空间中绘制文本。很难可视化多维空间，所以让我们从二维空间开始。  想象一个有 x 和 y 轴的图。我们的机器学习模型将在这个图上绘制各种点。这可以表示单词、句子、段落、文档，甚至是图像。  点的绘制位置由你使用的模型决定。模型将你传递的数据转换为向量。然后，它将向量绘制在图表上。    在进行搜索时，我们将为搜索词创建一个新的向量。然后我们将在图表上绘制这个新向量。    然后，我们将找到最接近搜索词的单词。最接近的单词将是那些在图表上离搜索词最近的单词。  最接近的术语将取决于你用来计算向量之间距离的算法。使用欧几里得距离，最接近的单词将是那些离搜索词最近的单词。    向量搜索还提供余弦算法。使用余弦距离，最接近的单词将是那些离搜索词最近，但方向相同的单词。    ","version":"当前版本","tagName":"h2"},{"title":"我们如何创建向量？​","type":1,"pageTitle":"📘 什么是向量？","url":"/search-lab/zh/docs/vector-search/what-are-vector#我们如何创建向量","content":" 生成式 AI 的重大突破在于开发者现在可以轻松使用已经预训练并在线免费提供的模型。这些模型经过了大量数据集的训练，能够将文本（或任何类型的数据）转换为向量。  有很多方法可以创建向量。在本次研讨会中，我们将使用一个预训练模型和一个将为我们返回向量的 API。 ","version":"当前版本","tagName":"h2"}],"options":{"languages":["en","zh"],"id":"default"}}