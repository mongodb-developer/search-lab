"use strict";(self.webpackChunksearch_party_lab=self.webpackChunksearch_party_lab||[]).push([[9679],{762:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var s=t(4848),r=t(8453);const i={},o="\ud83e\uddb8\u200d\u2642\ufe0f Testing the Hybrid Search",a={id:"hybrid-search/testing-hybrid-search",title:"\ud83e\uddb8\u200d\u2642\ufe0f Testing the Hybrid Search",description:"Extra activity, do it if you have extra time or are following at home, won't be covered during the hands-on Lab.",source:"@site/docs/8-hybrid-search/3-testing-hybrid-search.mdx",sourceDirName:"8-hybrid-search",slug:"/hybrid-search/testing-hybrid-search",permalink:"/search-lab/docs/hybrid-search/testing-hybrid-search",draft:!1,unlisted:!1,editUrl:"https://github.com/mongodb-developer/search-lab/blob/main/docs/8-hybrid-search/3-testing-hybrid-search.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud83e\uddb8\u200d\u2642\ufe0f Implementing Hybrid Search",permalink:"/search-lab/docs/hybrid-search/implementing-hybrid-search"},next:{title:"\ud83c\udfaf Summary",permalink:"/search-lab/docs/summary"}},l={},c=[];function h(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"\ufe0f-testing-the-hybrid-search",children:"\ud83e\uddb8\u200d\u2642\ufe0f Testing the Hybrid Search"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"Extra activity, do it if you have extra time or are following at home, won't be covered during the hands-on Lab."})}),"\n",(0,s.jsx)(n.p,{children:"Here's the complete code snippet to implement a hybrid search against the books collection."}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"See complete code"}),(0,s.jsx)("div",{children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'    //...\n    private computeWeightedRRF(books: Book[], weight: number): void{\n        const RANK_CONSTANT = 60;\n        books.forEach((book,i)=>{\n            book[\'score\'] = weight*1/(i+RANK_CONSTANT)\n            return book;\n        })\n    }\n\n    public async fullTextSearch(query: string,limit: number): Promise<Book[]>{\n        const pipeline = [\n            {\n              $search: {\n                index: "fulltextsearch",\n                compound: {\n                  should: [\n                    {\n                      text: {\n                        query,\n                        path: "title",\n                        score: { boost: { value: 3 } }\n                      }\n                    },\n                    {\n                        text: {\n                          query,\n                          path: "synopsis",\n                          score: { boost: { value: 2 } }\n                        }\n                    },\n                    {\n                      text: {\n                        query,\n                        path: "authors.name",\n                        score: { boost: { value: 2 } }\n                      }\n                    }\n                  ]\n                }\n              }\n            },{\n              $limit: limit\n            },{\n              $project:{ //project only relevant fields\n                title: 1, authors: 1, synopsis:1, cover:1\n              }\n            }\n          ]\n        const books = await collections?.books?.aggregate(pipeline).toArray() as Book[];\n        return books;\n    }\n\n    public async vectorSearch(query: string, limit: number): Promise<Book[]>{\n        const vector = await getEmbeddings(query);\n        const pipeline = [\n            {\n                $vectorSearch: {\n                  queryVector:  vector,\n                  path: \'embeddings\',\n                  numCandidates: 100,\n                  index: \'vectorsearch\',\n                  limit: limit,\n                }\n            },{\n                $project:{ //project only relevant fields\n                  title: 1, authors: 1, synopsis:1, cover:1\n                }\n            }\n          ]\n        const books = await collections?.books?.aggregate(pipeline).toArray() as Book[];\n        return books;\n    }\n\n    public async searchBooks(query: string): Promise<Book[]> {\n        const VECTOR_WEIGHT = 0.6;\n        const FULL_TEXT_WEIGHT = 0.4;\n        const SEARCH_LIMIT = 6\n\n        //run full text search and vector search separately\n        const [fts_results,vs_results] = await Promise.all([\n            this.fullTextSearch(query, SEARCH_LIMIT),\n            this.vectorSearch(query, SEARCH_LIMIT)\n        ])\n\n        //compute weighted Reciprocal Rank Fusion on both results\n        this.computeWeightedRRF(fts_results, FULL_TEXT_WEIGHT)\n        this.computeWeightedRRF(vs_results, VECTOR_WEIGHT)\n\n        //aggregate both arrays to a single map using _id as a key\n        const documentMap = [...fts_results,...vs_results].reduce((map,book:any)=>{\n            if(map.hasOwnProperty(book._id)){\n                map[book._id].score += book.score;\n            }else{\n                map[book._id] = book;\n            }\n            return map;\n        },{})\n\n        //transform map back to an array\n        const books = Object.keys(documentMap).map(k=>documentMap[k]);\n\n        //return books with the highest scores\n        const topBooks = books.sort((a,b)=>b.score-a.score).slice(0,SEARCH_LIMIT);\n        return topBooks;\n      }\n    //...\n'})})})]}),"\n",(0,s.jsxs)(n.p,{children:["You can observe the effect of hybrid search on the search results by tuning the ",(0,s.jsx)(n.strong,{children:"VECTOR_WEIGHT"})," and ",(0,s.jsx)(n.strong,{children:"FULL_TEXT_WEIGHT"}),".\nLets use the search term ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"basketball"})})," and compare the results. Note that your results may look different as we may periodically make changes to the dataset."]}),"\n",(0,s.jsxs)(n.p,{children:["Lets start with setting ",(0,s.jsx)(n.code,{children:"VECTOR_WEIGHT=0"})," and ",(0,s.jsx)(n.code,{children:"FULL_TEXT_WEIGHT=1"})," i.e. the results will be based on 100% full-text search."]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Here are the top 6 titles:"}),(0,s.jsx)("div",{children:(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The New York Knicks Basketball Team (Great Sports Teams)"}),"\n",(0,s.jsx)(n.li,{children:"In the Land of Giants: My Life in Basketball"}),"\n",(0,s.jsx)(n.li,{children:"Venus to the Hoop: A Gold Medal Year in Women's Basketball"}),"\n",(0,s.jsx)(n.li,{children:"Night Hoops"}),"\n",(0,s.jsx)(n.li,{children:"Cat (Fear Street Series #45)"}),"\n",(0,s.jsx)(n.li,{children:"NBA: The Official Fan's Guide"}),"\n"]})})]}),"\n",(0,s.jsxs)(n.p,{children:["Now, lets set ",(0,s.jsx)(n.code,{children:"VECTOR_WEIGHT=1"})," and ",(0,s.jsx)(n.code,{children:"FULL_TEXT_WEIGHT=0"})," i.e. the results will be based on 100% vector search."]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Here are the top 6 titles:"}),(0,s.jsx)("div",{children:(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"NBA: The Official Fan's Guide"}),"\n",(0,s.jsx)(n.li,{children:"In the Land of Giants: My Life in Basketball"}),"\n",(0,s.jsx)(n.li,{children:"Night Hoops"}),"\n",(0,s.jsx)(n.li,{children:"Venus to the Hoop: A Gold Medal Year in Women's Basketball"}),"\n",(0,s.jsx)(n.li,{children:"The New York Knicks Basketball Team (Great Sports Teams)"}),"\n",(0,s.jsx)(n.li,{children:"The Big Three"}),"\n"]})})]}),"\n",(0,s.jsxs)(n.p,{children:["Finally, lets set ",(0,s.jsx)(n.code,{children:"VECTOR_WEIGHT=0.6"})," and ",(0,s.jsx)(n.code,{children:"FULL_TEXT_WEIGHT=0.4"})," i.e. we are placing equal empahasis on full-text search and vector search."]}),"\n",(0,s.jsxs)(t,{children:[(0,s.jsx)("summary",{children:"Here are the top 6 titles:"}),(0,s.jsx)("div",{children:(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"In the Land of Giants: My Life in Basketball"}),"\n",(0,s.jsx)(n.li,{children:"NBA: The Official Fan's Guide"}),"\n",(0,s.jsx)(n.li,{children:"The New York Knicks Basketball Team (Great Sports Teams)"}),"\n",(0,s.jsx)(n.li,{children:"Night Hoops"}),"\n",(0,s.jsx)(n.li,{children:"Venus to the Hoop: A Gold Medal Year in Women's"}),"\n",(0,s.jsx)(n.li,{children:"The Big Three"}),"\n"]})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key observations:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["From the full-text search result, ",(0,s.jsx)(n.strong,{children:"Cat (Fear Street Series #45)"})," can be seen as a false positive because it may have little to do with basketball but it is only there because the synopsis contains the word ",(0,s.jsx)(n.strong,{children:"basketball"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["From the vector search result, ",(0,s.jsx)(n.strong,{children:"The Big Three"})," made it to the top 6 because it showed a few basketball players on its cover image, but this title was missed in the full-text search because neither the title nor the synopsis contains the word ",(0,s.jsx)(n.strong,{children:"basketball"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"From the hybrid search result, titles that made it to both types of search were ranked higher"}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);