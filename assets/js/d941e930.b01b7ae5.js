"use strict";(self.webpackChunksearch_party_lab=self.webpackChunksearch_party_lab||[]).push([[5184],{8294:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>h,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var s=r(4848),t=r(8453);const o={},i="\ud83e\uddb8\u200d\u2642\ufe0f Implementing Hybrid Search",c={id:"hybrid-search/implementing-hybrid-search",title:"\ud83e\uddb8\u200d\u2642\ufe0f Implementing Hybrid Search",description:"Extra activity, do it if you have extra time or are following at home, won't be covered during the hands-on Lab.",source:"@site/docs/8-hybrid-search/2-implementing-hybrid-search.mdx",sourceDirName:"8-hybrid-search",slug:"/hybrid-search/implementing-hybrid-search",permalink:"/search-lab/docs/hybrid-search/implementing-hybrid-search",draft:!1,unlisted:!1,editUrl:"https://github.com/mongodb-developer/search-lab/blob/main/docs/8-hybrid-search/2-implementing-hybrid-search.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud83d\udcd8 Introduction to Hybrid Search",permalink:"/search-lab/docs/hybrid-search/intro"},next:{title:"\ud83e\uddb8\u200d\u2642\ufe0f Testing the Hybrid Search",permalink:"/search-lab/docs/hybrid-search/testing-hybrid-search"}},h={},l=[{value:"Prerequites",id:"prerequites",level:2},{value:"Function for Full-Text Search",id:"function-for-full-text-search",level:2},{value:"Function for Vector Search",id:"function-for-vector-search",level:2},{value:"Function to compute Weighted Reciprocal Rank Fusion",id:"function-to-compute-weighted-reciprocal-rank-fusion",level:2},{value:"Function to perform Hybrid Search",id:"function-to-perform-hybrid-search",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components},{Details:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"\ufe0f-implementing-hybrid-search",children:"\ud83e\uddb8\u200d\u2642\ufe0f Implementing Hybrid Search"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"Extra activity, do it if you have extra time or are following at home, won't be covered during the hands-on Lab."})}),"\n",(0,s.jsxs)(n.p,{children:["In this section, we'll explore how we can implement Hybrid Search using ",(0,s.jsx)(n.a,{href:"https://www.mongodb.com/docs/atlas/atlas-vector-search/tutorials/reciprocal-rank-fusion/#what-is-reciprocal-rank-fusion-",children:"Reciprocal Rank Fusion"}),", a common technique used to combine results from different search methods."]}),"\n",(0,s.jsxs)(n.p,{children:["The MongoDB documentation shows how you can implement the ",(0,s.jsx)(n.a,{href:"https://www.mongodb.com/docs/atlas/atlas-vector-search/tutorials/reciprocal-rank-fusion/#procedure-1",children:"Hybrid Search using a single aggregation pipeline"}),". However, in this lab, we will combine the results from vector search and full-text search with application logic instead."]}),"\n",(0,s.jsx)(n.h2,{id:"prerequites",children:"Prerequites"}),"\n",(0,s.jsx)(n.p,{children:"This segment depends on the setup you have done in previous exercises:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Ensure you have ",(0,s.jsx)(n.a,{href:"https://mongodb-developer.github.io/search-lab/docs/search/search-index",children:"created an Atlas Search index"})," on the ",(0,s.jsx)(n.strong,{children:"books"})," collection with ",(0,s.jsx)(n.strong,{children:"dynamic mappings"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Ensure you have ",(0,s.jsx)(n.a,{href:"https://mongodb-developer.github.io/search-lab/docs/vector-search/import-data",children:"imported the embeddings"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Ensure you have ",(0,s.jsx)(n.a,{href:"https://mongodb-developer.github.io/search-lab/docs/vector-search/create-index",children:"created the vector search index"})," on the ",(0,s.jsx)(n.strong,{children:"embeddings"})," field."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"function-for-full-text-search",children:"Function for Full-Text Search"}),"\n",(0,s.jsxs)(n.p,{children:["Write a new function called ",(0,s.jsx)(n.code,{children:"fullTextSearch"})," in ",(0,s.jsx)(n.code,{children:"books.ts"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["It accepts ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"query"})})," as an argument of ",(0,s.jsx)(n.strong,{children:"string"})," type, and ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"limit"})})," as an argument of ",(0,s.jsx)(n.strong,{children:"number"})," type"]}),"\n",(0,s.jsxs)(n.li,{children:["Using ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"query"})}),", it should perform a full-text search on ",(0,s.jsx)(n.strong,{children:"title"}),", ",(0,s.jsx)(n.strong,{children:"synopsis"}),", and ",(0,s.jsx)(n.strong,{children:"author names"}),", and you may boost scores at your own discretion"]}),"\n",(0,s.jsxs)(n.li,{children:["It should limit the number of books returned using the ",(0,s.jsx)(n.strong,{children:"limit"})," argument parsed"]}),"\n",(0,s.jsxs)(n.li,{children:["Using ",(0,s.jsx)(n.code,{children:"$project"})," to only return the following book properties: ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"_id"})}),", ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"title"})}),", ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"authors"})}),", ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"synopsis"})}),", and ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"cover"})})]}),"\n"]}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"Answer"}),(0,s.jsx)("div",{children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'    public async fullTextSearch(query: string,limit: number): Promise<Book[]>{\n        const pipeline = [\n            {\n              $search: {\n                index: "fulltextsearch",\n                compound: {\n                  should: [\n                    {\n                      text: {\n                        query,\n                        path: "title",\n                        score: { boost: { value: 3 } }\n                      }\n                    },\n                    {\n                        text: {\n                          query,\n                          path: "synopsis",\n                          score: { boost: { value: 2 } }\n                        }\n                    },\n                    {\n                      text: {\n                        query,\n                        path: "authors.name",\n                        score: { boost: { value: 2 } }\n                      }\n                    }\n                  ]\n                }\n              }\n            },{\n              $limit: limit\n            },{\n              $project:{ //project only relevant fields\n                title: 1, authors: 1, synopsis:1, cover:1\n              }\n            }\n          ]\n        const books = await collections?.books?.aggregate(pipeline).toArray() as Book[];\n        return books;\n    }\n\n'})})})]}),"\n",(0,s.jsx)(n.h2,{id:"function-for-vector-search",children:"Function for Vector Search"}),"\n",(0,s.jsxs)(n.p,{children:["Write a new function called ",(0,s.jsx)(n.code,{children:"vectorSearch"})," in ",(0,s.jsx)(n.code,{children:"books.ts"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["It accepts ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"query"})})," as an argument of ",(0,s.jsx)(n.strong,{children:"string"})," type, and ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"limit"})})," as an argument of ",(0,s.jsx)(n.strong,{children:"number"})," type"]}),"\n",(0,s.jsxs)(n.li,{children:["It should vectorize the ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"query"})})," and use resulting vector to perform a vector search on ",(0,s.jsx)(n.strong,{children:"books"})," collection."]}),"\n",(0,s.jsxs)(n.li,{children:["It should limit the number of books returned using the ",(0,s.jsx)(n.strong,{children:"limit"})," argument parsed"]}),"\n",(0,s.jsxs)(n.li,{children:["Using ",(0,s.jsx)(n.code,{children:"$project"})," to only return the following book properties: ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"_id"})}),", ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"title"})}),", ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"authors"})}),", ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"synopsis"})}),", and ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"cover"})})]}),"\n"]}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"Answer"}),(0,s.jsx)("div",{children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"    public async vectorSearch(query: string, limit: number): Promise<Book[]>{\n        const vector = await getEmbeddings(query);\n        const pipeline = [\n            {\n                $vectorSearch: {\n                  queryVector:  vector,\n                  path: 'embeddings',\n                  numCandidates: 100,\n                  index: 'vectorsearch',\n                  limit: limit,\n                }\n            },{\n                $project:{ //project only relevant fields\n                  title: 1, authors: 1, synopsis:1, cover:1\n                }\n            }\n          ]\n        const books = await collections?.books?.aggregate(pipeline).toArray() as Book[];\n        return books;\n    }\n\n"})})})]}),"\n",(0,s.jsxs)(n.h2,{id:"function-to-compute-weighted-reciprocal-rank-fusion",children:["Function to compute Weighted ",(0,s.jsx)(n.a,{href:"https://www.mongodb.com/docs/atlas/atlas-vector-search/tutorials/reciprocal-rank-fusion/#what-is-reciprocal-rank-fusion-",children:"Reciprocal Rank Fusion"})]}),"\n",(0,s.jsx)(n.p,{children:"Atlas full-text search and vector search, by default, returns documents sorted by their relevancy score from highest to lowest i.e. they are ranked by default."}),"\n",(0,s.jsxs)(n.p,{children:["A reciprocal rank score is given by ",(0,s.jsx)(n.code,{children:"1 / (RANK * RANK_CONSTANT)"}),". A ",(0,s.jsx)(n.strong,{children:"RANK_CONSTANT"})," (typically about 60), prevents the case of ",(0,s.jsx)(n.code,{children:"1/0"})," where ",(0,s.jsx)(n.strong,{children:"RANK"})," is 0, and smoothens the scores so that it is not too heavily skewed towards higher ranked documents."]}),"\n",(0,s.jsx)(n.p,{children:"You may give different weightage to full-text search versus vector search by multiplying the scores with a different weight."}),"\n",(0,s.jsxs)(n.p,{children:["Write a new private function called ",(0,s.jsx)(n.code,{children:"computeWeightedRRF"})," in ",(0,s.jsx)(n.code,{children:"books.ts"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["It accepts ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"books"})})," as an argument of ",(0,s.jsx)(n.strong,{children:"Book[]"})," type, and ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"weight"})})," as an argument of ",(0,s.jsx)(n.strong,{children:"number"})," type"]}),"\n",(0,s.jsx)(n.li,{children:"It should compute the Reciprocal Rank score based on its position in the array (the first book in the array should be ranked 0)."}),"\n",(0,s.jsxs)(n.li,{children:["Mulitply the score further by the given ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"weight"})})," and store the resultant score as ",(0,s.jsx)(n.code,{children:"score"})," back into the book object."]}),"\n"]}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"Answer"}),(0,s.jsx)("div",{children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"    private computeWeightedRRF(books: Book[], weight: number): void{\n        const RANK_CONSTANT = 60;\n        books.forEach((book,i)=>{\n            book['score'] = weight*1/(i+RANK_CONSTANT)\n            return book;\n        })\n    }\n"})})})]}),"\n",(0,s.jsx)(n.h2,{id:"function-to-perform-hybrid-search",children:"Function to perform Hybrid Search"}),"\n",(0,s.jsx)(n.p,{children:"The final thing we need to do is to combine the scores by summing the scores from both types of searches.\nIf the same book is found in two searches, the score should be summed up giving it a higher score."}),"\n",(0,s.jsxs)(n.p,{children:["Replace the ",(0,s.jsx)(n.code,{children:"searchBooks"})," function in ",(0,s.jsx)(n.code,{children:"books.ts"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["It accepts ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"query"})})," as an argument of ",(0,s.jsx)(n.strong,{children:"string"})," type"]}),"\n",(0,s.jsxs)(n.li,{children:["It should execute both full-text search and vector search based on the ",(0,s.jsx)(n.em,{children:(0,s.jsx)(n.strong,{children:"query"})})]}),"\n",(0,s.jsxs)(n.li,{children:["It should parse both results into the ",(0,s.jsx)(n.code,{children:"computeWeightedRRF"}),". Lets give full-text search a weight of ",(0,s.jsx)(n.strong,{children:"0.5"})," and vector search a weight of ",(0,s.jsx)(n.strong,{children:"0.5"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Sum the two scores from both sets of results, re-rank the books based on the new scores and return the ",(0,s.jsx)(n.strong,{children:"top 5"})," books"]}),"\n"]}),"\n",(0,s.jsxs)(r,{children:[(0,s.jsx)("summary",{children:"Answer"}),(0,s.jsx)("div",{children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"    public async searchBooks(query: string): Promise<Book[]> {\n        const VECTOR_WEIGHT = 0.5;\n        const FULL_TEXT_WEIGHT = 0.5;\n        const SEARCH_LIMIT = 5\n\n        //run full text search and vector search separately\n        const [fts_results,vs_results] = await Promise.all([\n            this.fullTextSearch(query, SEARCH_LIMIT),\n            this.vectorSearch(query, SEARCH_LIMIT)\n        ])\n\n        //compute weighted Reciprocal Rank Fusion on both results\n        this.computeWeightedRRF(fts_results, FULL_TEXT_WEIGHT)\n        this.computeWeightedRRF(vs_results, VECTOR_WEIGHT)\n\n        //aggregate both arrays to a single map using _id as a key\n        const documentMap = [...fts_results,...vs_results].reduce((map,book:any)=>{\n            if(map.hasOwnProperty(book._id)){\n                map[book._id].score += book.score;\n            }else{\n                map[book._id] = book;\n            }\n            return map;\n        },{})\n\n        //transform map back to an array\n        const books = Object.keys(documentMap).map(k=>documentMap[k]);\n\n        //return books with the highest scores\n        const topBooks = books.sort((a,b)=>b.score-a.score).slice(0,SEARCH_LIMIT);\n        return topBooks;\n      }\n"})})})]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>c});var s=r(6540);const t={},o=s.createContext(t);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);